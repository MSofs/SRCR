%Base de Conhecimento (aqui so esta uma pequena parte da mesma de forma a ser possivel testar) !

pontoRecolha(-9.14330880914792,38.7080787857025,355,"misericórdia",15805,"lixos",cv0090,90).
pontoRecolha(-9.14330880914792,38.7080787857025,356,"misericórdia",15805,"embalagens",cv0240,1680).
pontoRecolha(-9.14330880914792,38.7080787857025,357,"misericórdia",15805,"lixos",cv0090,90).
pontoRecolha(-9.14330880914792,38.7080787857025,358,"misericórdia",15805,"papel e cartão",cv0240,1440).
pontoRecolha(-9.14330880914792,38.7080787857025,359,"misericórdia",15805,"papel e cartão",cv0090,90).
pontoRecolha(-9.14337777820218,38.7080781891571,364,"misericórdia",15806,"lixos",cv0240,240).
pontoRecolha(-9.14337777820218,38.7080781891571,365,"misericórdia",15806,"lixos",cv0140,840).
pontoRecolha(-9.14337777820218,38.7080781891571,366,"misericórdia",15806,"lixos",cv0120,120).
pontoRecolha(-9.14337777820218,38.7080781891571,367,"misericórdia",15806,"lixos",cv0090,180).
pontoRecolha(-9.14337777820218,38.7080781891571,368,"misericórdia",15806,"embalagens",cv0240,240).
pontoRecolha(-9.14337777820218,38.7080781891571,369,"misericórdia",15806,"lixos",cv0140,840).
pontoRecolha(-9.14337777820218,38.7080781891571,370,"misericórdia",15806,"lixos",cv0120,120).
pontoRecolha(-9.14337777820218,38.7080781891571,360,"misericórdia",15806,"lixos",cv0090,180).
pontoRecolha(-9.14337777820218,38.7080781891571,361,"misericórdia",15806,"papel e cartão",cv0140,280).
pontoRecolha(-9.14337777820218,38.7080781891571,362,"misericórdia",15806,"papel e cartão",cv0090,90).
pontoRecolha(-9.14337777820218,38.7080781891571,363,"misericórdia",15806,"papel e cartão",ca0090,90).
pontoRecolha(-9.14348180670535,38.7073026157039,371,"misericórdia",15807,"lixos",cv0240,240).
pontoRecolha(-9.14348180670535,38.7073026157039,372,"misericórdia",15807,"lixos",cv0140,420).
pontoRecolha(-9.14348180670535,38.7073026157039,373,"misericórdia",15807,"lixos",cv0240,240).
pontoRecolha(-9.14348180670535,38.7073026157039,374,"misericórdia",15807,"lixos",cv0140,420).
pontoRecolha(-9.14348180670535,38.7073026157039,375,"misericórdia",15807,"papel e cartão",cv0240,240).
pontoRecolha(-9.14348180670535,38.7073026157039,376,"misericórdia",15807,"papel e cartão",cv0140,140).
pontoRecolha(-9.14255098678099,38.7073286838222,377,"misericórdia",15808,"lixos",cv0140,280).
pontoRecolha(-9.14255098678099,38.7073286838222,378,"misericórdia",15808,"lixos",cv0240,960).
pontoRecolha(-9.14255098678099,38.7073286838222,379,"misericórdia",15808,"lixos",cv0140,280).
pontoRecolha(-9.14255098678099,38.7073286838222,380,"misericórdia",15808,"lixos",cv0240,960).
pontoRecolha(-9.14276596081499,38.7070836135523,381,"misericórdia",15809,"vidro",cv0140,280).
pontoRecolha(-9.14276596081499,38.7070836135523,382,"misericórdia",15809,"embalagens",cv0120,120).
pontoRecolha(-9.1426225690344,38.7066975168166,383,"misericórdia",15810,"lixos",cv0240,960).
pontoRecolha(-9.1426225690344,38.7066975168166,384,"misericórdia",15810,"lixos",cv0240,960).
pontoRecolha(-9.1426225690344,38.7066975168166,385,"misericórdia",15810,"papel e cartão",cv0240,240).
pontoRecolha(-9.14240835587344,38.7069966274245,386,"misericórdia",15811,"lixos",cv0140,420).
pontoRecolha(-9.14240835587344,38.7069966274245,387,"misericórdia",15811,"vidro",cv0240,960).
pontoRecolha(-9.14240835587344,38.7069966274245,388,"misericórdia",15811,"lixos",cv0140,420).
pontoRecolha(-9.14240835587344,38.7069966274245,389,"misericórdia",15811,"lixos",cv0240,960).
pontoRecolha(-9.14240835587344,38.7069966274245,390,"misericórdia",15811,"papel e cartão",cv0240,240).
pontoRecolha(-9.14305015543156,38.7068559589223,391,"misericórdia",15812,"lixos",cv0140,700).
pontoRecolha(-9.14305015543156,38.7068559589223,392,"misericórdia",15812,"lixos",cv0240,720).
pontoRecolha(-9.14305015543156,38.7068559589223,393,"misericórdia",15812,"embalagens",cv0120,360).
pontoRecolha(-9.14305015543156,38.7068559589223,394,"misericórdia",15812,"lixos",cv0140,700).
pontoRecolha(-9.14305015543156,38.7068559589223,395,"misericórdia",15812,"lixos",cv0240,720).
pontoRecolha(-9.14305015543156,38.7068559589223,396,"misericórdia",15812,"lixos",cv0120,360).
pontoRecolha(-9.1512511235953,38.7087754470349,397,"misericórdia",15813,"lixos",cv0240,2400).
pontoRecolha(-9.1512511235953,38.7087754470349,398,"misericórdia",15813,"vidro",cv0140,980).
pontoRecolha(-9.1512511235953,38.7087754470349,399,"misericórdia",15813,"embalagens",cv0090,90).
pontoRecolha(-9.1512511235953,38.7087754470349,400,"misericórdia",15813,"lixos",cv0240,2400).
pontoRecolha(-9.1512511235953,38.7087754470349,401,"misericórdia",15813,"lixos",cv0140,980).
pontoRecolha(-9.1512511235953,38.7087754470349,402,"misericórdia",15813,"lixos",cv0090,90).
pontoRecolha(-9.15178946418214,38.7086356323308,406,"misericórdia",15814,"vidro",cv0120,240).
pontoRecolha(-9.15178946418214,38.7086356323308,407,"misericórdia",15814,"lixos",cv0140,700).
pontoRecolha(-9.15178946418214,38.7086356323308,408,"misericórdia",15814,"lixos",cv0090,90).
pontoRecolha(-9.15178946418214,38.7086356323308,409,"misericórdia",15814,"lixos",cv0240,480).
pontoRecolha(-9.15178946418214,38.7086356323308,410,"misericórdia",15814,"embalagens",cv0120,240).
pontoRecolha(-9.15178946418214,38.7086356323308,403,"misericórdia",15814,"lixos",cv0140,700).
pontoRecolha(-9.15178946418214,38.7086356323308,404,"misericórdia",15814,"lixos",cv0090,90).
/*
ligacao(15805,15806,0.007668852022762408).
ligacao(15805,15807,0.09668852022762408).

ligacao(15806,15808,0.10592211834585856).

ligacao(15807,15806,0.08592211834585856).
ligacao(15807,15808,0.10353696624591671).

ligacao(15808,15809,0.035987888121274576).

ligacao(15809,15810,0.045284048092640354).

ligacao(15810,15811,0.04056442435564734).

ligacao(15811,15812,0.07301314974359344).
*/
ligacao(15805,15807,0.9).
ligacao(15805,15806,0.5).

ligacao(15806,15808,1).
%ligacao(15806,15809,2).
%ligacao(15806,15807,0.5).

ligacao(15807,15806,1).
ligacao(15807,15812,0).

ligacao(15808,15809,2).

ligacao(15809,15810,0.045284048092640354).

ligacao(15810,15811,0.04056442435564734).

ligacao(15811,15812,0.07301314974359344).

escrever([]).
escrever([H|T]) :-
	write(H), write("\n"),
	escrever(T).

nao( Questao ) :-
    Questao, !, fail.
nao( Questao ).


appendToList([],L,L).
appendToList([H|T],L,[H|Z]):- appendToList(T,L,Z).
appendToListS([],L).
appendToListS(R,[R|L]).

inverteLista([],Z,Z).
inverteLista([H|T],Z,Acc) :- inverteLista(T,Z,[H|Acc]).


inverso(Xs, Ys):-
	inverso(Xs, [], Ys).

inverso([], Xs, Xs).
inverso([X|Xs],Ys, Zs):-
	inverso(Xs, [X|Ys], Zs).

procuraId(_,[],[]).
procuraId(Nodo,[pontoRecolha(_,_,Id,_,Nodo,_,_,_)|T],[Id|R]):-procuraId(Nodo,T,R).
procuraId(Nodo,[_|T],R):-procuraId(Nodo,T,R).

eliminaRepetidos(X, R) :- eliminaRepAux(X,[],R), !.

eliminaRepAux([],Acc,Acc).
eliminaRepAux([X|XS],Acc,R) :- member(X,Acc), eliminaRepAux(XS,Acc,R).
eliminaRepAux([X|XS],Acc,R) :- eliminaRepAux(XS,[X|Acc],R).

seleciona(E, [E|Xs], Xs).
seleciona(E, [X|Xs], [X|Ys]) :- seleciona(E, Xs, Ys).


% Verifica se um elemento existe numa lista
membro(X, [X|_]).
membro(X, [_|Xs]):-
        membro(X,Xs).

minimoMedia([(P,X)],(P,X)).
minimoMedia([(Px,X)|L],(Py,Y)):- minimoMedia(L,(Py,Y)),length(Px,R),length(Py,R1), X/R>Y/R1.
minimoMedia([(Px,X)|L],(Px,X)):- minimoMedia(L,(Py,Y)), length(Px,R),length(Py,R1), X/R=<Y/R1.


minimoMediaA([(Lista,Cu)],(Lista,Cu)).
minimoMediaA([([(Id,_)|L],Cu)|Tail],(Py,Y)):- NumeroId = 1, Cu/NumeroId,minimoMediaA(Tail,(Py,Y)),X/R>Y/R1.
minimoMediaA(_,(Px,X)):- minimoMediaA(L,(Py,Y)), length(Px,R),length(Py,R1), X/R=<Y/R1.

numeroId(([],_),0).
numeroId([([(Id,_)|L],Cu)|Tail],N):- numeroId(L,N1), N is N1 +1.

minimo([(P,X)],(P,X)).
minimo([(_,X)|L],(Py,Y)):- minimo(L,(Py,Y)), X>Y.
minimo([(Px,X)|L],(Px,X)):- minimo(L,(_,Y)), X=<Y.


displayCost(R) :- format('\nCost=~3f',R).
displayNode(R) :- format('\nNode=~w',R).
displayGeneral(Text, R) :- format('\n~w = ~w',[Text, R]).
displayList(([])).
displayList((A,C)) :- escrever(A),write("\n"),displayCost(C).

soma([],0).
soma([H|T],S):-soma(T,G),S is H+G.

%- Depth-first Search -----------------------

resolvePPCusto(Inicial,Final,[Inicial|Caminho],Custo):-
    primeiroprofundidadeCusto(Inicial,Final,[Inicial],Caminho,Custo).


primeiroprofundidadeCusto(Nodo,Final, _, [], 0):-Nodo ==Final.

primeiroprofundidadeCusto(Nodo,Final,Historico,[NodoProx|Caminho],Custo):-
    adjacenteCusto(Nodo,NodoProx,CustoMovimento),
    nao(member(NodoProx, Historico)),
    primeiroprofundidadeCusto(NodoProx,Final,[NodoProx|Historico],Caminho,Custo2),
    Custo is CustoMovimento + Custo2.

adjacenteCusto(Nodo, NodoProx, Custo):-
    ligacao(Nodo,NodoProx,Custo).

%- Depth-first Search - Para tipo de lixo e freguesia especifica -----------------------
resolvePPLixo(Inicial,Final,Freguesia,[(Inicial,R)|Caminho],TipoLixo,Q):-
    findall(Id,pontoRecolha(_,_,Id,Freguesia,Inicial,TipoLixo,_,_),R),
    primeiroprofundidadeCustoL(Inicial,Final,Freguesia,[(Inicial,R)],Caminho,TipoLixo,Q).


primeiroprofundidadeCustoL(Nodo,Final,_, _, [],_,0):-Nodo ==Final.

primeiroprofundidadeCustoL(Nodo,Final,Freguesia,Historico,[(NodoProx,Id2)|Caminho],TipoLixo,Q):-
    adjacenteCustoL(Nodo,(NodoProx,Id2),Freguesia,TipoLixo,Q1),
    nao(member((NodoProx,Id2), Historico)),
    primeiroprofundidadeCustoL(NodoProx,Final,Freguesia,[(NodoProx,Id2)|Historico],Caminho,TipoLixo,Q2),
    Q is Q1+Q2.

adjacenteCustoL(Nodo, (NodoProx,Id2),Freguesia,TipoLixo,Q):-
    ligacao(Nodo,NodoProx,_),
    findall(Id,pontoRecolha(_,_,Id,Freguesia,NodoProx,TipoLixo,_,_),Id2),
    findall(Q1,pontoRecolha(_,_,_,_,Nodo,_,_,Q1),QT1),
    findall(Q2,pontoRecolha(_,_,_,_,NodoProx,_,_,Q2),QT2),
    soma(QT1,R),
    soma(QT2,R1),
    Q is R + R1.


ppCustoTodasSolucoes(Inicial,Final,L):- findall((S,C),(resolvePPCusto(Inicial,Final,S,C)),L).

ppTodasSolucoes(Inicial,Final,L):- findall(C,(resolvePPCusto(Inicial,Final,C,_)),L).

ppTodasSolucoesL(Inicial,Final,T,L):- findall(C,(resolvePPLixo(Inicial,Final,_,C,T,_)),R),eliminaRepetidos(R,L).

%-Breadth-first Search - Para tipo de lixo e freguesia especifica---------------------------------------

resolve_breathFirst(PontoRecolha, Inicial, Final, CaminhoFinal) :-
	procuraId(Inicial,PontoRecolha,L),eliminaRepetidos(L,R),
    breadthFirstSearch(PontoRecolha,[[(Inicial,R)]], Final, Solucao),
    inverteLista(Solucao, CaminhoFinal, []).

breadthFirstSearch(_,[[(Nodo,Id)|Caminho]|_], Final, [(Nodo,Id)|Caminho]) :- Nodo == Final.

breadthFirstSearch(PontoRecolha, [[(N,Id)|Caminho]|CaminhoList], Final, Solucao) :-
        bagof([(PN,ID), (N,Id)|Caminho],
        (adjacenteBF(PontoRecolha, N, (PN,ID)), \+ membro((PN,ID), [(N,Id)|Caminho])), NovosCaminhos),
        append(CaminhoList, NovosCaminhos, Res), !,
        breadthFirstSearch(PontoRecolha, Res, Final, Solucao);
        breadthFirstSearch(PontoRecolha, CaminhoList, Final, Solucao).

adjacenteBF(PontoRecolha, Nodo, (NodoAdj,Id)) :-
       ligacao(Nodo,NodoAdj, _),
       procuraId(NodoAdj,PontoRecolha,L),eliminaRepetidos(L,Id).


% A* Search --------------------

resolve_astar(Inicial, Final, CaminhoFinal/Custo,Q) :-
	astarSearch([[Inicial]/0], Final, CaminhoReversed/Custo,Q),
        inverteLista(CaminhoReversed, CaminhoFinal, []).

astarSearch( Caminhos, Final, Caminho,_) :-
	bestPathAsearch(Caminhos, Caminho),
	Caminho = [Nodo|_]/_, Nodo == Final.

astarSearch( Caminhos, Final, SolucaoCaminho,Q) :-
	bestPathAsearch(Caminhos, MelhorCaminho),
	seleciona(MelhorCaminho, Caminhos, OutrosCaminhos),
	expand_astar( MelhorCaminho, Final, ExpCaminhos,Q2),
	append(OutrosCaminhos, ExpCaminhos, NovoCaminhos),
	astarSearch( NovoCaminhos, Final, SolucaoCaminho,Q1),
	Q is Q2+Q1.

bestPathAsearch([Caminho], Caminho) :- !.

bestPathAsearch([Caminho1/Custo1,_/Custo2|Caminhos], MelhorCaminho) :-
	Custo1  =< Custo2 , !,
	bestPathAsearch([Caminho1/Custo1|Caminhos], MelhorCaminho).

bestPathAsearch([_|Caminhos], MelhorCaminho) :-
	bestPathAsearch(Caminhos, MelhorCaminho).

expand_astar( Caminho, Final, ExpCaminhos,Q) :-
	findall(NovoCaminho, adjacenteAStar( Caminho, Final, NovoCaminho,Q), ExpCaminhos).

adjacenteAStar([Nodo|Caminho]/Custo, _, [ProxNodo,Nodo|Caminho]/NovoCusto,Q) :-
        verificarLigacaoAStar( Nodo, ProxNodo,Q),
	findall(Q1,pontoRecolha(_,_,_,_,Nodo,_,_,Q1),R1),
	findall(Q2,pontoRecolha(_,_,_,_,ProxNodo,_,_,Q2),R2),
	soma(R1,L1),soma(R2,L2),
	Q is L1 + L2,
	\+ membro(ProxNodo, Caminho),
        ligacao( Nodo, ProxNodo, PassoCusto),
        NovoCusto is Custo + PassoCusto.

verificarLigacaoAStar( Nodo, ProxNodo,Q) :-
	ligacao(Nodo, ProxNodo, C2).

%-A* - Para um dado tipo de lixo e freguesia ----------------------------------------------------------
resolve_aestrela(Nodo,Final,Caminho/Custo,Freguesia,TipoLixo) :-
	findall(Id,pontoRecolha(_,_,Id,Freguesia,Nodo,TipoLixo,_,_),R),
	aestrela([[(Nodo,R)]/0], Final,InvCaminho/Custo,Freguesia,TipoLixo),
	inverso(InvCaminho, Caminho).

aestrela(Caminhos,Final, Caminho,_,_) :-
	obtem_melhor(Caminhos, Caminho),
	Caminho = [(Nodo,_)|_]/_,Nodo==Final.

aestrela(Caminhos,Final, SolucaoCaminho,Freguesia,TipoLixo) :-
	obtem_melhor(Caminhos, MelhorCaminho),
	seleciona(MelhorCaminho, Caminhos, OutrosCaminhos),
	expande_aestrela(MelhorCaminho, ExpCaminhos,Freguesia,TipoLixo),
	append(OutrosCaminhos, ExpCaminhos, NovoCaminhos),
    aestrela(NovoCaminhos,Final, SolucaoCaminho,Freguesia,TipoLixo).

obtem_melhor([Caminho], Caminho) :- !.

obtem_melhor([Caminho1/Custo1,_/Custo2|Caminhos], MelhorCaminho) :-
	Custo1 =< Custo2, !,
	obtem_melhor([Caminho1/Custo1|Caminhos], MelhorCaminho).

obtem_melhor([_|Caminhos], MelhorCaminho) :-
	obtem_melhor(Caminhos, MelhorCaminho).

expande_aestrela(Caminho, ExpCaminhos,Freguesia,TipoLixo) :-
	findall(NovoCaminho, adjacente(Caminho,NovoCaminho,Freguesia,TipoLixo), ExpCaminhos).

adjacente([(Nodo,Id)|Caminho]/Custo, [(ProxNodo,R),(Nodo,Id)|Caminho]/NovoCusto,Freguesia,TipoLixo) :-
	ligacao(Nodo, ProxNodo, PassoCusto),\+ member(ProxNodo, Caminho),
	findall(ID,pontoRecolha(_,_,ID,Freguesia,ProxNodo,TipoLixo,_,_),R),
	NovoCusto is Custo + PassoCusto.

aTodasSolucoesL(Inicial,Final,T,L):- findall(C,(resolve_aestrela(Inicial,Final,C/Cu,_,T)),R),eliminaRepetidos(R,L).

%-Greedy/Gulosa--------------------------------------------------------------------------------------------------------

resolveGulosa(Nodo, Final,Caminho/Custo,Freguesia, TipoLixo) :-
    findall(Id,pontoRecolha(_,_,Id,Freguesia,Nodo,TipoLixo,_,_),R),
    agulosa([[(Nodo,R)]/0],Final, CaminhoInverso/Custo,Freguesia,TipoLixo),
    inverso(CaminhoInverso, Caminho).

agulosa(Caminhos,Final, Caminho,_,_) :-
    obtem_melhor_g(Caminhos, Caminho),
    Caminho = [(Nodo,_)|_]/_,Nodo==Final.

agulosa(Caminhos,Final, SolucaoCaminho,Freguesia,TipoLixo) :-
    obtem_melhor_g(Caminhos, MelhorCaminho),
    seleciona(MelhorCaminho, Caminhos, OutrosCaminhos),
    expandeGulosa(MelhorCaminho, ExpCaminhos,Freguesia,TipoLixo),
    append(OutrosCaminhos, ExpCaminhos, NovoCaminhos),
    agulosa(NovoCaminhos,Final, SolucaoCaminho,Freguesia,TipoLixo).

obtem_melhor_g([Caminho], Caminho) :- !.

obtem_melhor_g([Caminho1/Custo1,_/_|Caminhos], MelhorCaminho) :-
	obtem_melhor_g([Caminho1/Custo1|Caminhos], MelhorCaminho).

obtem_melhor_g([_|Caminhos], MelhorCaminho) :-
	obtem_melhor_g(Caminhos, MelhorCaminho).

expandeGulosa(Caminho, ExpCaminhos,Freguesia,TipoLixo) :-
	findall(NovoCaminho, adjacenteG(Caminho,NovoCaminho,Freguesia,TipoLixo), ExpCaminhos).

adjacenteG([(Nodo,Id)|Caminho]/Custo, [(ProxNodo,R),(Nodo,Id)|Caminho]/NovoCusto,Freguesia,TipoLixo) :-
	ligacao(Nodo, ProxNodo, PassoCusto),\+ member(ProxNodo, Caminho),
	findall(ID,pontoRecolha(_,_,ID,Freguesia,ProxNodo,TipoLixo,_,_),R),
	NovoCusto is Custo + PassoCusto.

gTodasSolucoesL(Inicial,Final,T,L):- findall(C,(resolveGulosa(Inicial,Final,C/Cu,_,T)),R),eliminaRepetidos(R,L).

g1TodasSolucoesL(Inicial,Final,T,L):- findall(C,(geraCircuito_tipoLixoG(Inicial,Final,C/_,T)),R),eliminaRepetidos(R,L).


%-Greedy/Gulosa- Para tipo de lixo e freguesia especifica --------------------------
resolveGulosa1(Nodo, Final,Caminho/Custo) :-
    agulosa1([[Nodo]/0],Final, CaminhoInverso/Custo),
    inverso(CaminhoInverso, Caminho).

agulosa1(Caminhos,Final, Caminho) :-
    obtem_melhor_g1(Caminhos, Caminho),
    Caminho = [Nodo|_]/_,Nodo==Final.

agulosa1(Caminhos,Final, SolucaoCaminho) :-
    obtem_melhor_g1(Caminhos, MelhorCaminho),
    seleciona(MelhorCaminho, Caminhos, OutrosCaminhos),
    expandeGulosa1(MelhorCaminho, ExpCaminhos),
    append(OutrosCaminhos, ExpCaminhos, NovoCaminhos),
    agulosa1(NovoCaminhos,Final, SolucaoCaminho).

obtem_melhor_g1([Caminho], Caminho) :- !.

obtem_melhor_g1([Caminho1/Custo1,_/_|Caminhos], MelhorCaminho) :-
	obtem_melhor_g1([Caminho1/Custo1|Caminhos], MelhorCaminho).

obtem_melhor_g1([_|Caminhos], MelhorCaminho) :-
	obtem_melhor_g1(Caminhos, MelhorCaminho).

expandeGulosa1(Caminho, ExpCaminhos) :-
	findall(NovoCaminho, adjacenteG1(Caminho,NovoCaminho), ExpCaminhos).

adjacenteG1([Nodo|Caminho]/Custo, [ProxNodo,Nodo|Caminho]/NovoCusto) :-	ligacao(Nodo, ProxNodo, PassoCusto),\+ member(ProxNodo, Caminho),
	NovoCusto is Custo + PassoCusto.

% ------Ponto 1------Gerar os circuitos de recolha tanto indiferenciada como seletiva, caso existam, que cubram uma determinada freguesia----------------------------------------------------------------------

geraCircuito_tipoLixoDF(Origem, Destino,Freguesia, TipoLixo,Caminho) :-
	  resolvePPLixo(Origem,Destino,Freguesia,Caminho,TipoLixo,_),write("Caminho \n"),escrever(Caminho).

geraCircuito_tipoLixoBF(Origem, Destino,Freguesia,TipoLixo,Caminho) :-
	findall(pontoRecolha(La,Lo,Id,Freguesia,Nodo,TipoLixo,C,Cap), pontoRecolha(La,Lo,Id,Freguesia,Nodo,TipoLixo,C,Cap), PontosRecolha),
	resolve_breathFirst(PontosRecolha, Origem, Destino, Caminho),write("Caminho \n"),escrever(Caminho).


geraCircuito_tipoLixoA(Origem, Destino,Freguesia, TipoLixo,Caminho/CostTime) :-
	resolve_aestrela(Origem, Destino,Caminho/CostTime,Freguesia,TipoLixo),write("Caminho \n"),escrever(Caminho),displayCost(CostTime).

geraCircuito_tipoLixoG(Origem, Destino,Freguesia, TipoLixo,Caminho/CostTime) :-
	resolveGulosa(Origem, Destino, Caminho/CostTime,Freguesia,TipoLixo),write("Caminho \n"),escrever(Caminho),displayCost(CostTime).


%-----Ponto 2----Identificar quais os circuitos com mais pontos de recolha (por tipo de resíduo a recolher)-------------------------------------
numeroParagens([],0).
numeroParagens([(_,P)|T],N):-
	numeroParagens(T,NR),
	length(P,Nu),N is NR + Nu.


numeroParagens1([],0).
numeroParagens1([X|Tail],(Nu|N)):-
	numeroParagens(X,Nu),
	numeroParagens1(Tail,N).

getMaior([],Max,R,C,T):-R = C, T = Max.
getMaior([X|Tail],Max,R,C,T):-
	(   numeroParagens(X,N),
	    N >Max ->
	    Max1 = N,
	    C1 = X,
	    getMaior(Tail,Max1,R,C1,T);
	    getMaior(Tail,Max,R,C,T)
	).


getMaisParagensDF(I,F,TipoLixo,P,T):-
	ppTodasSolucoesL(I,F,TipoLixo,L),getMaior(L,0,P,C,T).

getMaisParagensA(I,F,TipoLixo,P,T):-
	aTodasSolucoesL(I,F,TipoLixo,L),getMaior(L,0,P,C,T).

getMaisParagensG(I,F,TipoLixo,P,T):-
	gTodasSolucoesL(I,F,TipoLixo,L),getMaior(L,0,P,C,T).


%---Ponto 3---Comparar circuitos de recolha tendo em conta o indicador de produtividade de minima distancia media---------------------------------------------------------------------------------

%([15805, 15807, 15806], 1.9)
%([15805, 15807, 15812, 15806], 0.9)
%Ca = ([15805, 15807, 15812, 15806, 15808],1.9 )

comparaCircuito1(C1, C2,R):-
	minimoMedia([C1,C2],R).

% [(15805, [355, 357]),  (15806, [364, 365, 366, 367, 369, 370, 360])]/0.5
%[(15805, [355, 357]),  (15807, [371, 372, 373, 374]),  (15812, [391, 392, 394, 395, 396]),  (15806, [364,365,366,367,369,370,360])/0.9
comparaCircuito2(C1/CU1, C2/CU2, C1,CU1):-
	getLengths(C1,R1),getLengths(C2,R2), CU1/R1=<CU2/R2.
comparaCircuito2(C1/CU1, C2/CU2, C2,CU2):-
	getLengths(C1,R1),getLengths(C2,R2), CU1/R1>CU2/R2.


comparaCircuitosPA(I,F,R):-
	resolvePPCusto(I,F,C1,CU1),
	resolve_astar(I,F,C2/CU2,_),
	comparaCircuito1((C1,CU1),(C2,CU2),R).

comparaCircuitosPG(I,F,R):-
	resolvePPCusto(I,F,C1,CU1),
	resolveGulosa1(I,F,C2/CU2),
	comparaCircuito1((C1,CU1),(C2,CU2),R).

comparaCircuitosPP(I,F,R):-
	resolvePPCusto(I,F,C1,CU1),
	comparaCircuito1((C1,CU1),(C1,CU1),R).


getLengths([],0).
getLengths([(_,P)|T],R):- length(P,R1),getLengths(T,R2), R is R1 + R2 .

getOrigem([],0).
getOrigem([(Origem,_)|T],Origem):-!.

getDestino([],0).
getDestino([(Destino,_)],Destino):-!.
getDestino([(_,_)|T],Destino):-getDestino(T,Destino).



% -------- Ponto 4-------Escolher o circuito mais rápido (usando o critério da distância)-----------------------------------------------------------------
aTodasSolucoes(Inicial,Final,L):- findall(C,(resolve_astar(Inicial,Final,C/Cu)),R),eliminaRepetidos(R,L).
gTodasSolucoes(Inicial,Final,L):- findall(C,(resolveGulosa1(Inicial,Final,C/Cu)),R),eliminaRepetidos(R,L).

melhorP(Inicial,Final,R):- findall((Ca,Cus), resolvePPCusto(Inicial,Final,Ca,Cus), L),minimo(L,R).
melhorA(Inicial,Final,R):- findall((Ca,Cus), resolve_astar(Inicial,Final,Ca/Cus,_), L),minimo(L,R).
melhorG(Inicial,Final,R):- findall((Ca,Cus), resolveGulosa1(Inicial,Final,Ca/Cus), L),minimo(L,R).

mais_rapidoA(Origem, Destino, Caminho/CostTime) :-
   resolve_astar(Origem,Destino,Caminho/CostTime,_),write("Caminho \n"),escrever(Caminho),displayCost(CostTime).

mais_rapidoG(Origem, Destino, Caminho/CostTime) :-
    resolveGulosa1(Origem ,Destino, Caminho/CostTime),write("Caminho \n"),escrever(Caminho),displayCost(CostTime).

mais_rapidoP(Origem, Destino,Caminho) :-
	melhorP(Origem ,Destino,Caminho),
	write("Caminho\n"),displayList(Caminho).


%----Ponto 5--Escolher o circuito mais eficiente (usando um critério de menor distância média percorrida entre pontos de recolha)------------------------------------------------------------------

melhorMedia(Inicial,Final,R):- ppCustoTodasSolucoes(Inicial,Final,L),minimoMedia(L,R).
melhorMediaG(Inicial,Final,R):-  findall((Ca,Cus), resolveGulosa1(Inicial,Final,Ca/Cus), L),minimoMedia(L,R).

melhorMediaA(Inicial,Final,R):-
	findall((Ca,Cus), resolve_astar(Inicial,Final,Ca/Cus,_), L),minimoMedia(L,R).

mais_rapidoMediaP(Origem, Destino,Caminho) :-
	melhorMedia(Origem ,Destino,Caminho),
	write("Caminho\n"),displayList(Caminho).


mais_rapidoMediaG(Origem,Destino,Caminho):-
	melhorMediaG(Origem,Destino,Caminho),
	write("Caminho\n"),displayList(Caminho).


mais_rapidoMediaA(Origem,Destino,Caminho):-
	melhorMediaA(Origem,Destino,Caminho),
	write("Caminho\n"),displayList(Caminho).




%-Extra-----Quantidade Recolhida num dado circuito------------------

quantidadeRecolhidaPL(Origem,Destino,L,R):-
	resolvePPLixo(Origem,Destino,_,C,L,R),escrever(C).

quantidadeRecolhidaA(Origem,Destino,R):-
	resolve_astar(Origem,Destino,C/_,R),escrever(C).
